Today's tasks:
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ] 
- [ ]  

### Other notes

#### API Testing
When do I need to extract logic to a service?
- I reuse certain logic multiple times between different endpoints.



Charlotte meeting discussion:
- Only work on the RouteToStart once the API ticket is finished. Put priority on the API ticket.
- Refactor the handlers such that:
    - `FieldBoundaryShortcutHandler` always happens clockwise and counterclockwise
    - The `PointToPointHandler` handles both scenarios, and selects the strategy based on the result of `PointToPointRoute.MainlandLineSegments`
- Attempt to use lazy variables by:
    - Split the `RouteToStart` context by just the stuff that the `CCDubins` turn needs.
    - Create an additional record for all point to point related results (`PointToPointContext`? Maybe a little confusing)
    - Implement laziness inside the `RouteToStartHandler`.



### More API stuff

  

We only want to create services when:
- You have functionality that is used in multiple places (e.g. validation, data access).
- The functionality is complex enough to warrant its own unit tests.
- You only create an interface of it if you need Dependency Injection.

An example of a service is the FieldValidator.


Naming conventions:
- Every end point gets its own name. 



## API Testing strategy
The main idea behind our strategy is to keep it as simple as possible.

Here are the rules for testing:
1. Every endpoint will be tested.
2. Every service will be tested.
3. We do not mock our own library, unless really necessary.
4. We make fakes for our data storage following the repository pattern.
5. We skip End-to-end tests for now and focus on unit and integration tests.
6. We mock the logger.

We could consider mocking our actual routing part if it takes a long time and we want to speed up the test, but we'll keep this for later (we don't need this now, so we're not doing it, and most of the routing logic will be tested in-library anyway).












Exception: Mock only if:

The dependency is genuinely slow (>1 second per test)
You have separate comprehensive tests for that dependency
You're testing error handling/edge cases that are hard to trigger with real implementation




So, to summarize this conversation:
- Don't mock or fake AgxRouteLib, because that's the core logic that we want to test and own. (Technically, we can mock this library to test just this simple API wrapper layer, but using the KISS principle it's not worth it.)
- Use Fakes for external dependencies, specifically:
  - CosmosDB/Blob storage/Event grid
- Use services only when it gets used multiple times.
- It's fine if services don't depend on IService if I don't mock it. Services also don't have to end on service.


Few questions:
What if a service depends on another service. We still don't want to mock it to isolate the tests more? We could also mock our own core logic just to test the thin layer? Is that not worth it?


Then, in the end, I will have:
- Services tests
- Endpoint tests